export Agent

import Functors: functor
using Setfield: @set

"""
    Agent(;kwargs...)

A wrapper of an `AbstractPolicy`. Generally speaking, it does nothing but to
update the trajectory and policy appropriately in different stages.

# Keywords & Fields

- `policy`::[`AbstractPolicy`](@ref): the policy to use
- `trajectory`::[`AbstractTrajectory`](@ref): used to store transitions between an agent and an environment
"""
Base.@kwdef struct Agent{P<:AbstractPolicy,T<:AbstractTrajectory} <: AbstractPolicy
    policy::P
    trajectory::T
end

functor(x::Agent) = (policy = x.policy,), y -> @set x.policy = y.policy

(agent::Agent)(env) = agent.policy(env)

function check(agent::Agent, env::AbstractEnv)
    if ActionStyle(env) === FULL_ACTION_SET &&
       !haskey(agent.trajectory, :legal_actions_mask)
        @warn "The env[$(nameof(env))] is of FULL_ACTION_SET, but I can not find a trace named :legal_actions_mask in the trajectory"
    end
    check(agent.policy, env)
end

"""
Here we extend the definition of `(p::AbstractPolicy)(::AbstractEnv)` in
`RLBase` to accept an `AbstractStage` as the first argument. Algorithm designers
may customize these behaviors respectively. The default behaviors are:
1. Update the inner `trajectory` given the context of `policy`, `env`, and
   `stage`.
  1. By default we do nothing.
  2. In `PreActStage`, we `push!` the current **state** of the `env` and the
     **action** generated by `policy(env)` into the `trajectory`. And the
     **action** is returned.
  3. In `PostActStage`, we query the `reward` and `is_terminated` info from
     `env` and push them into `trajectory`.
  4. For `CircularSARTTrajectory`:
     1. In the `PosEpisodeStage`, we push the `state` at the end of an episode
        and a dummy action into the `trajectory`.
     1. In the `PreEpisodeStage`, we pop out the lastest `state` and `action`
        pair (which are dummy ones) from `trajectory`.
2. Update the inner `policy` given the context of `trajectory`, `env`, and
   `stage`.
  1. By default, we only `update!` the `policy` in the `PreActStage`. And it's
     despatched to `update!(policy, trajectory)`.
"""
function (agent::Agent)(stage::AbstractStage, env::AbstractEnv)
    update!(agent.trajectory, agent.policy, env, stage)
    update!(agent.policy, agent.trajectory, env, stage)
end

function (agent::Agent)(stage::PreActStage, env::AbstractEnv)
    action = update!(agent.trajectory, agent.policy, env, stage)
    update!(agent.policy, agent.trajectory, env, stage)
    action
end

RLBase.update!(::AbstractPolicy, ::AbstractTrajectory, ::AbstractEnv, ::AbstractStage) =
    nothing

RLBase.update!(p::AbstractPolicy, t::AbstractTrajectory, ::AbstractEnv, ::PreActStage) =
    update!(p, t)

RLBase.update!(::AbstractTrajectory, ::AbstractPolicy, ::AbstractEnv, ::AbstractStage) =
    nothing

function RLBase.update!(
    trajectory::Union{
        CircularArraySARTTrajectory,
        CircularArraySLARTTrajectory,
        PrioritizedTrajectory{<:CircularArraySARTTrajectory},
        PrioritizedTrajectory{<:CircularArraySLARTTrajectory},
    },
    ::AbstractPolicy,
    ::AbstractEnv,
    ::PreEpisodeStage,
)
    if length(trajectory) > 0
        pop!(trajectory[:state])
        pop!(trajectory[:action])
        if :legal_actions_mask in keys(trajectory)
            pop!(trajectory[:legal_actions_mask])
        end
    end
end

function RLBase.update!(
    trajectory::Union{
        CircularArraySARTTrajectory,
        CircularArraySLARTTrajectory,
        PrioritizedTrajectory{<:CircularArraySARTTrajectory},
        PrioritizedTrajectory{<:CircularArraySLARTTrajectory},
    },
    policy::AbstractPolicy,
    env::AbstractEnv,
    ::Union{PreActStage,PostEpisodeStage},
)
    action = policy(env)
    push!(trajectory[:state], state(env))
    push!(trajectory[:action], action)
    if :legal_actions_mask in keys(trajectory)
        push!(trajectory[:legal_actions_mask], legal_action_space_mask(env))
    end
    action
end

function RLBase.update!(
    trajectory::AbstractTrajectory,
    ::AbstractPolicy,
    env::AbstractEnv,
    ::PostActStage,
)
    push!(trajectory[:reward], reward(env))
    push!(trajectory[:terminal], is_terminated(env))
end
